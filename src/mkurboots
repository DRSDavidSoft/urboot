#!/bin/bash

# published under GNU General Public License, version 3 (GPL-3.0)
# author Stefan Rueger <stefan.rueger@urclocks.com>
# 01.01.2023

# Compile bootloaders for one MCU

progname=$(basename $0)

Usage() {
cat <<END
Syntax: $progname [<opt>] <mcu>
Function: create bootloaders for the 8-bit AVR MCU <mcu> (all lower case)
Option:
    -m <dir>  directory in which mcu bootloaders are created (default mcus)
    -b <dir>  directory in which board bootloaders are created (default boards)
    -c <dir>  directory in which core bootloaders are created (default cores)
    -f <fcpu> only create bootloaders for certain F_CPU values, eg, -f auto,16000000,8000000
    -B <baud> only create bootloaders for certain baud rates, eg, -B auto,115200,38400
    -d        dry run: show which bootloaders would be created
END
}

shopt -s extglob

# Maximum allowed UART/SWIO baud rate quantisation errors in ppm (22000 is 2.2%)
declare -A maxioerror
# External oscillators are relatively precise, can afford high quantisation error
maxioerror[x]=22000
# Space Fcpu for internal oscillators by 1%, so want quantisation error < 0.5%
maxioerror[i]=4999

declare -A ftypedir
ftypedir[x]=external_oscillator/fcpu
ftypedir[i]=internal_oscillator/fcpu

run=1
mcu_bls=mcus
board_bls=boards
core_bls=cores
fcpulist=""
baudlist=""
here=$(pwd)

while getopts ":dm:b:c:f:B:" opt; do
  case ${opt} in
    m) mcu_bls=$OPTARG
        ;;
    b) board_bls=$OPTARG
        ;;
    c) core_bls=$OPTARG
        ;;
    f) fcpulist=$OPTARG
        ;;
    B) baudlist=$OPTARG
        ;;
    d) run=0
        ;;
    --) shift;
        break
        ;;
   \?) echo "Invalid option: $OPTARG" 1>&2
       Usage 1>&2; exit 1
       ;;
   : ) echo "Invalid option: $OPTARG requires an argument" 1>&2
       Usage 1>&2; exit 1
       ;;
  esac
done
shift $((OPTIND -1))

if [ $# != 1 ]; then Usage 1>&2; exit 1; fi


mcu="$1"

####
# Some intell about parts in general
#

source ur_avrintel

####
# setarray arr , 1,2,3,
# Split a string into an array
#

setarray(){ declare -n a=$1; local IFS=$2 -; set -f; a=($3); }

####
# Set out for which targets, F_CPUs, baud rates and I/O lines (for SW I/O) to compile
#

####
# Baud rate and F_CPU combinations
#

# Map F_CPU to baud rates: compile for these combinations
# Many are redundant: eg, 16 MHz @ 115200 baud is the same as 8 MHz @ 57600 baud
declare -A baud

# Popular external Fcpus
fcpus=(24000000 22118400 20000000 18432000 16000000 14745600 12000000 11059200 10000000 9216000 \
  8000000 7372800 6000000 5529600 5000000 4608000 4000000 3686400 3000000 2764800 2500000 2304000 \
  2000000 1843200 1500000 1382400 1000000 921600 500000 460800 250000 230400 125000)

# Add internal Fcpus
setarray internalfcpu / "${intfcpus[$mcu]}"
for ifcpu in ${internalfcpu[@]}; do
  # Adding +4 also generates b/l for Fcpu +/-1%, Fcpu +/- 2%, ... Fcpu +/- 4%
  if [[ $ifcpu -gt 30000 ]]; then 
    fcpus+=($ifcpu+4)
  fi
done

extbauds=1000000/500000/250000/125000/921600/576000/460800/230400
allbauds=115200/76800/57600/38400/28800/19200/14400/9600/7200/4800/2400/1800/1200/600/300

baud[auto]=auto
for fcpu in ${fcpus[@]}; do
  if [[ $fcpu == *+[0-8] ]]; then baud[$fcpu]=$allbauds; else baud[$fcpu]=$extbauds/$allbauds; fi
done

# Remove computation for F_CPU values not mentioned in -f
if [[ -n $fcpulist ]]; then
  setarray flist , "$fcpulist"
  declare -A fcpuok
  for ff in ${flist[@]}; do
     fcpuok[$ff]=1;
  done
  for fcpu in ${!baud[@]}; do
     if [[ -z ${fcpuok[$fcpu]} ]]; then
       unset baud[$fcpu]
     fi
  done
fi

# Create list of -B baud rates
declare -A baudok
if [[ -n $baudlist ]]; then
  setarray blist , "$baudlist"
  for bb in ${blist[@]}; do
     baudok[$bb]=1
  done
fi

# List of considered F_CPUs in descending order
fcpus=($(printf '%s\n' "${!baud[@]}" | sort -rn))


####
# Known boards
#

# At least generate a template bootloader (with placeholder nops)
board=none:TEMPLATE=1

# Various boards have the LED on different pins, some low active
if [[ $mcu == atmega328p ]]; then
  board+=/urclock,timeduino,jeenode:LEDPOLARITY=-1_LED=AtmelPB1
  board+=/anarduino,moteino:LED=AtmelPB1
  board+=/urclockusb:LED=AtmelPD5
  board+=/ursense:LEDPOLARITY=-1_LED=AtmelPD5
  board+=/uno,rbbb,promini,minicore:LED=AtmelPB5
  board+=/dual:TEMPLATE=1_DUAL=1
  board+=/urclock,timeduino:LEDPOLARITY=-1_LED=AtmelPB1_SFMCS=AtmelPB0_DUAL=1
  board+=/anarduino:LED=AtmelPB1_SFMCS=AtmelPD5_DUAL=1
  board+=/moteino:LED=AtmelPB1_SFMCS=AtmelPB0_DUAL=1
  board+=/urclockusb:LED=AtmelPD5_SFMCS=AtmelPB0_DUAL=1
  board+=/ursense:LEDPOLARITY=-1_LED=AtmelPD5_SFMCS=AtmelPB0_DUAL=1
fi
if [[ $mcu == attiny85 ]]; then
  board+=/digispark:LED=AtmelPB1
fi
if [[ $mcu == attiny88 ]]; then
  board+=/mh-tiny:LED=AtmelPD0
fi
if [[ $mcu == attiny167 ]]; then
  board+=/digispark-pro:LED=AtmelPB1
fi
if [[ $mcu == attiny84 ]]; then
  board+=/luminet:LED=AtmelPA4
fi
if [[ $mcu == atmega1284p ]]; then
  board+=/bobuino,mighty1284,wildfire-v2,mightycore:LED=AtmelPB7
  board+=/mightycore:LED=AtmelPB0
  board+=/wildfire:LED=AtmelPB5
  board+=/moteinomega:LED=AtmelPD7
  board+=/urclockmega:LED=AtmelPC7
  board+=/dual:TEMPLATE=1_DUAL=1
  board+=/moteinomega:LED=AtmelPD7_SFMCS=AtmelPC7_DUAL=1
  board+=/urclockmega:LED=AtmelPC7_SFMCS=AtmelPB3_DUAL=1
fi
if [[ $mcu == atmega644p ]]; then
  board+=/sanguino,mightycore:LED=AtmelPB0
  board+=/mightycore:LED=AtmelPB7
fi
if [[ $mcu == atmega2560 ]]; then
  board+=/mega-r3,megacore:LED=AtmelPB7
fi
if [[ $mcu == atmega1280 ]]; then
  board+=/mega1280,megacore:LED=AtmelPB7
fi

# Treat MightyCore, MiniCore, MegaCore and MajorCore initially as boards (note some are already subsumed above)
if [[ /atmega1284/atmega644a/atmega324pb/atmega324pa/atmega324p/atmega324a/atmega164p/atmega164a/atmega32/atmega16/atmega8535/ =~ /$mcu/ ]]; then
  board+=/mightycore:LED=AtmelPB0
  board+=/mightycore:LED=AtmelPB7
elif [[ /atmega328pb/atmega328/atmega168pb/atmega168p/atmega168/atmega88pb/atmega88p/atmega88/atmega48pb/atmega48p/atmega48/atmega8/ =~ /$mcu/ ]]; then
  board+=/minicore:LED=AtmelPB5
elif [[ /atmega6490p/atmega6490/atmega6450p/atmega6450/atmega3290p/atmega3290/atmega3250p/atmega3250/atmega640/ =~ /$mcu/ ]]; then
  board+=/megacore:LED=AtmelPB7
elif [[ /atmega2561/atmega1281/atmega649p/atmega649/atmega645p/atmega645/atmega329p/atmega329/atmega325p/atmega325/atmega169p/atmega169a/atmega165p/atmega165a/atmega128/atmega64/at90can128/at90can64/at90can32/ =~ /$mcu/ ]]; then
  board+=/megacore:LED=AtmelPB5
elif [[ /atmega162/atmega8515/ =~ /$mcu/ ]]; then
  board+=/majorcore:LED=AtmelPB0
elif [[ /attiny13/attiny13a/ =~ /$mcu/ ]]; then
  board+=/microcore:LED=AtmelPB2
fi


# All the I/O specs for *this* MCU
setarray iospecs \| "${mcuio[$mcu]}"

# Variation of autobaud on certain parts that can only detect fcpu/16, fcpu/32, fcpu/24, ...
autovar=; [[ /atmega103/at43usb320/at90s2313/at90s2333/at90s4433/at90s4414/at90s8515/at90s4434/at90s8535/ =~ /$mcu/ ]] && autovar=2

####
# Put human readable F_CPU into variable fcpunm
#
mkfcpunm() {
  local frq="$1";
  while [[ ${#frq} -lt 7 ]]; do frq="0$frq"; done
  frq="${frq::-6}m${frq: -6}"
  frq="${frq%%+(0)}"
  [[ ${frq: -1} == m ]] && frq=${frq}0
  [[ $1 -lt 10000000 ]] && frq="$2$frq"
  fcpunm="$frq"
}

####
# Put human readable baud rate into variable baudnm
#
mkbaudnm() {
  local bd="$1";
  while [[ ${#bd} -lt 4 ]]; do bd="0$bd"; done
  bd="${bd::-3}k${bd: -3:-2}"
  while [[ ${#bd} -lt 6 ]]; do bd="$2$bd"; done
  baudnm="$bd"
}

####
# Construct a global variable filename for the basename of the bootloader
#
mkfilename() {
  local cfg=$8
  [[ "$cfg" == TEMPLATE=1 ]] && cfg=_lednop
  [[ "$cfg" == TEMPLATE=1_DUAL=1 ]] && cfg=_template_dual
  cfg=${cfg/LEDPOLARITY=-1_LED=AtmelP/_led-}
  cfg=${cfg/LED=AtmelP/_led+}
  cfg=${cfg/_SFMCS=AtmelP/_cs}
  cfg=${cfg/_DUAL=1/_dual}
  cfg=${cfg,,}
  local swio=$9
  swio=${swio/SWIO=1/_swio}
  swio=${swio/UARTNUM=/_uart}
  swio=${swio/UARTALT=0/}
  swio=${swio/UARTALT=/_alt}
  swio=${swio/RX=AtmelP/_rx}
  swio=${swio/TX=AtmelP/_tx}
  swio=${swio// /}
  swio="${swio%"${swio##*[![:space:]]}"}"  # Remove trailing whitespace
  swio=${swio,,}
  if [[ $2 == auto* ]]; then
    filename="urboot_$1_autobaud$autovar$swio"
  else
    filename="urboot_$1_$2_$3$swio"
  fi
  [[ $5 -eq 1 ]] && filename+=_ee
  # Do not makes LEDs part of filename for FRILLS=0
  [[ $7 -eq 0 ]] || filename+=$cfg
  [[ $7 -eq 6 ]] && filename+=_fr
  [[ $7 -eq 7 ]] && filename+=_fr_ce
  [[ $6 -eq 0 ]] && filename+=_stk500
  [[ $4 -eq 0 ]] && filename+=_hw
}


alphabet=({a..z})

declare -A duplicate
declare -A hexuse
declare -A hexprotect
declare -A hexassoc
declare -A hexdirs
declare -A topdirs
declare -A divseen
declare -A equivalent

[[ $run == 1 ]] && mkdir -p "$mcu_bls/$mcu"

topmdir="$mcu_bls/$mcu"
topbdir="$board_bls/$mcu"
topcdir="$core_bls/_Core_/$mcu"

for fcpu in ${fcpus[@]}; do
  ftype=x
  ndf=0
  if [[ $fcpu == auto ]]; then
    fbase=16000000
    fcpunm=auto
  elif [[ $fcpu == *+[0-8] ]]; then
     # 9600000+4 means loop F_cpu from F_cpu-4% to F_cpu+4%
    ftype=i
    fbase=${fcpu%??}
    maxerr=maxioerror[i]
    ndf=${fcpu: -1}
  else
    fbase=$fcpu
    maxerr=maxioerror[x]
  fi

  setarray bauds / "${baud[$fcpu]}"
  for b in ${bauds[@]}; do
    if [[ -n $baudlist && -z ${baudok[$b]} ]]; then
      continue
    fi

    # Ensure br < Fcpu/100 for all internal oscillator Fcpu variations
    if [[ $ftype == i && $b -ge $(($fbase*(1-$ndf/100)/100)) ]]; then
      continue
    fi

    # Limit baud rates to be not smaller than f_cpu/1024
    if [[ $fcpu != auto && $b -lt $(($fbase/1024)) ]]; then
      continue
    fi

    [[ $fcpu != auto ]] && mkfcpunm $fbase +
    for (( df=-$ndf; df<=$ndf; df++ )); do
      thisfcpu=$(($fbase + $df*$fbase/100))

      preamble="$mcu"
      if [[ $b == auto ]]; then
        br=AUTOBAUD=1
        fchr=""
        preamble="Note that autobaud bootloaders normally can only detect host baud rates = f/8, f/16, ... f/2048 +/- 1.5%, where f=F<sub>CPU</sub>."
        preamble+=" Internal oscillators have a high unknown deviation: baud rates under f/260 are recommended for these."
        mdir="$topmdir/autobaud"
        bdir="$topbdir/autobaud"
        cdir="$topcdir/autobaud"
      else
        br=BAUD_RATE=$b
        # fcpu characterisation x (external) or j-4 (internal -4%) ... r+4 (internal +4%)
        fchr=x;
        if [[ $ftype == i && $df == 0 ]]; then
          fchr=i
        elif [[ $ftype == i ]]; then
          fchr=${alphabet[$((8+$df))]}$(printf "%+d" $df)
        fi
        mkbaudnm $b +
        mdir="$topmdir/${ftypedir[$ftype]}_${fcpunm}$fchr/br_${baudnm}"
        bdir="$topbdir/${ftypedir[$ftype]}_${fcpunm}$fchr/br_${baudnm}"
        cdir="$topcdir/${ftypedir[$ftype]}_${fcpunm}$fchr/br_${baudnm}"
        # Can this F_CPU/baud rate combo later be created from an existing one?
        # Bootloaders are the same (unless -DDEBUG_FREQ is used) if quotient $fbase/$b is the same
        div=$((100*$fbase/$b))/$fchr
        if [[ -z ${divseen[$div]} ]]; then
          divseen[$div]=$fbase/$b/$fchr/
        else
          equivalent[$fbase/$b/$fchr/]=${divseen[$div]}
          continue
        fi
      fi

      for io in "${iospecs[@]}"; do
        thisio="$io"
        if [[ $b == auto ]]; then
          # Autobaud needs UART and must have RX in I/O space: exclude ports H..L
          if [[ ${io:0:4} == SWIO ]]; then
            continue
          fi
          if [[ $io =~ RX=AtmelP[H-L] && "${uarttype[$mcu]}" -lt 3 ]]; then
            continue
          fi
        else
          # Classic or LIN UART experiences too high baud rate error for this F_CPU/baud combo?
          if [[ ${thisio:0:4} == UART && $(bauderror -am -f$thisfcpu -b$b $mcu) -gt $maxerr ]]; then
            # Switch to SWIO instead of using the UART
            thisio=${thisio/UARTNUM=?/SWIO=1}
            thisio=${thisio/UARTALT=?/}
          fi

          if [[ ${thisio:0:4} == SWIO ]]; then
            # Is the SWIO baud rate too high or too low?
            if [[ $(bauderror -sam -f$thisfcpu -b$b $mcu) -gt $maxerr ]]; then
              continue
            fi
            # Also needs RX/TX in I/O space: exclude ports H..L
            if [[ $io =~ [RT]X=AtmelP[H-L] && "${uarttype[$mcu]}" -lt 3 ]]; then
              continue
            fi
            preamble=$(bauderror -s -v -f$thisfcpu -b$b $mcu)
          else
            preamble=$(bauderror    -v -f$thisfcpu -b$b $mcu)
          fi
        fi

        for ur in 0 1; do
          # Only generate STK500 bootloaders ($ur = 0) for MCUs that have HW boot sections
          if [[ $ur -eq 0 && ${minbootsz[$mcu]} -eq 0 ]]; then
            continue;
          fi

          for ee in 0 1; do

            setarray brd / "$board"
            for bb in ${brd[@]}; do
              bcfg=${bb#*:}
              bname=${bb%:*}

              # Do not create STK500 b/loader with dual boot
              if [[ $ur -eq 0 && $bcfg =~ DUAL ]]; then
                continue;
              fi

              for vbl in 0 1; do
                # Do not generate hardware-supported bootloaders (vbl=0) for MCUs without HW boot sections
                if [[ $vbl -eq 0 && ${minbootsz[$mcu]} -eq 0 ]]; then
                  continue;
                fi
                # Do not generate vector boot loaders for STK500 protocol
                if [[ $vbl -eq 1 && $ur -eq 0 ]]; then
                  continue;
                fi

                hexname=()
                for f in 0 1 6 7; do
                  if [[ $f -eq 0 && $bname != none ]]; then
                    continue
                  fi
                  if [[ $ee -eq 0 && $f -gt 7 ]]; then
                    continue;
                  fi

                  mkfilename $mcu $fcpunm$fchr "$baudnm" $vbl $ee $ur $f "$bcfg" "$thisio"
                  args="MCU=$mcu F_CPU=${thisfcpu}L $br $thisio VBL=$vbl EEPROM=$ee ${bcfg//_/ } URPROTOCOL=$ur FRILLS=$f MOVETO=$filename"
                  if [[ $run -eq 1 ]]; then
                    make $args >& $filename.out
                    if [[ -r $filename.hex ]]; then
                      hexname+=("$filename")
                      hexlsout=($(hexls $filename.hex))
                      hexuse[$filename]=${hexlsout[1]}
                      hexprotect[$filename]=${hexlsout[3]:5:1} # p or P
                    else
                      echo warning compilation for $filename failed
                    fi
                  else
                    echo make $args
                    # echo "$mdir/$filename.hex"
                    if [[ -n ${duplicate[$filename]} ]]; then
                      echo duplicate $filename ${duplicate[$filename]}
                      echo duplicate $filename $args
                    else
                      duplicate[$filename]="$args"
                    fi
                  fi
                done
                if [[ $run -eq 1 ]]; then
                  # Delete bootloaders of same size that have fewer features and same protection
                  for (( i=0; i<${#hexname[@]}-1; i++ )); do
                    if [[ ${hexuse[${hexname[$i]}]} -ge ${hexuse[${hexname[$i+1]}]} ]]; then
                      if [[ ${hexprotect[${hexname[$i]}]} == ${hexprotect[${hexname[$i+1]}]} ]]; then
                        rm "${hexname[$i]}".{lst,elf,hex,out}
                      fi
                    fi
                  done
                  for hxn in ${hexname[@]}; do
                    if [[ -r $hxn.hex ]]; then
                      hexassoc[$hxn]="$mdir/$hxn"
                      if [[ -z ${hexdirs[$mdir]} ]]; then
                        mkdir -p "$mdir"
                        topdirs[$topmdir]=1
                        hexdirs[$mdir]="$preamble"
                      fi
                      mv $hxn.{hex,out,elf,lst} "$mdir/"
                      setarray brdali , "$bname"
                      for ba in ${brdali[@]}; do
                        if [[ $ba != none && $ba != dual ]]; then
                          # Make bootloader available under boards/cores directories, too
                          if [[ $ba/ =~ core/ ]]; then
                            badir=${cdir/_Core_/$ba}
                            topdirs[${topcdir/_Core_/$ba}]=1
                            banam=$hxn
                          else
                            badir=${bdir/$mcu/$ba}
                            topdirs[${topbdir/$mcu/$ba}]=1
                            banam=${hxn/$mcu/$ba}
                          fi
                          if [[ -z ${hexdirs[$badir]} ]]; then
                            mkdir -p $badir
                            hexdirs[$badir]="$preamble"
                          fi
                          hexassoc[$hxn]+="|$badir/$banam"
                          for ext in hex out elf lst; do
                            ln -f $mdir/$hxn.$ext $badir/$banam.$ext
                          done
                        fi
                      done
                    fi
                  done
                fi
              done
            done
          done
        done
      done
    done
  done
done

if [[ $run -eq 1 ]]; then
  # Remove all non _ee bootloaders that have the same usage as the _ee ones and the same protection
  todel=()
  for hxn in "${!hexassoc[@]}"; do
    if [[ $hxn == *_ee_* ]]; then
      hxnoee=${hxn//_ee/}
      if [[ -n ${hexassoc[$hxnoee]} ]]; then
        if [[ ${hexuse[$hxn]} -le ${hexuse[$hxnoee]} ]]; then
          if [[ ${hexprotect[$hxn]} == ${hexprotect[$hxnoee]} ]]; then
            setarray torm \| "${hexassoc[$hxnoee]}"
            for tormfn in ${torm[@]}; do
              rm $tormfn.{hex,lst,elf,out}
            done
            todel+=($hxnoee)
          fi
        fi
      fi
    fi
  done
  for torm in ${todel[@]}; do
    unset hexassoc[$torm]
  done

  # Remove all vector bootloaders that have the same usage as hw supported ones (protection might differ)
  todel=()
  for hxhard in "${!hexassoc[@]}"; do
    if [[ $hxhard == *_hw* ]]; then
      hxvbl=${hxhard//_hw/}
      if [[ -n ${hexassoc[$hxvbl]} ]]; then
        if [[ ${hexuse[$hxhard]} -le ${hexuse[$hxvbl]} ]]; then
          setarray torm \| "${hexassoc[$hxvbl]}"
          for tormfn in ${torm[@]}; do
            rm $tormfn.{hex,lst,elf,out}
          done
          todel+=($hxvbl)
        fi
      fi
    fi
  done
  for torm in ${todel[@]}; do
    unset hexassoc[$torm]
  done

  # Copy equivalent bootloaders over from ${equivalent[$combo]} to $combo
  for combo in ${!equivalent[@]}; do
    # echo Copy $combo from ${equivalent[$combo]}
    setarray fcpubd / "${equivalent[$combo]}"
    mkfcpunm ${fcpubd[0]} +
    mkbaudnm ${fcpubd[1]} +
    fchr=${fcpubd[2]}
    ftype=${fchr::1}; [[ $ftype != x ]] && ftype=i
    chfcpu=$fcpunm
    chbaud=$baudnm
    srcdir="${ftypedir[$ftype]}_${fcpunm}$fchr/br_${baudnm}"

    setarray fcpubd / "$combo"
    mkfcpunm ${fcpubd[0]} +
    mkbaudnm ${fcpubd[1]} +
    dstdir="${ftypedir[$ftype]}_${fcpunm}$fchr/br_${baudnm}"

    for dd in  ${!topdirs[@]}; do
      if [[ -d "$dd/$srcdir" ]]; then
        if [[ -z ${hexdirs["$dd/$dstdir"]} ]]; then
          mkdir -p "$dd/$dstdir"
          hexdirs["$dd/$dstdir"]="${hexdirs[$dd/$srcdir]}"
          if [[ -z ${hexdirs["$dd/$dstdir"]} ]]; then
            echo Warning: no preamble for "$dd/$srcdir"
          fi
        fi
        for src in "$dd/$srcdir"/*; do
          if [[ -r "$src" ]]; then
            dst=${src//_$chfcpu/_$fcpunm}
            dst=${dst//_$chbaud/_$baudnm}
            if [[ ! -r "$dst" ]]; then
              ln "$src" "$dst"
            fi
          fi
        done
      fi
    done
  done

  # Generate the README.md files
  for dir in "${!hexdirs[@]}"; do
    cd "$dir"
    "$here/hexls" -pre="${hexdirs[$dir]}" -sort -md "https://raw.githubusercontent.com/stefanrueger/urboot.hex/main/$dir" *.hex >README.md
    cd "$here"
  done
  hash cmpls 2>/dev/null && cmpls -p $mcu_bls/$mcu | grep \\.hex >>/tmp/equivalent-hex-files.txt
fi
